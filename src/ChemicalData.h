/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef CHEMICALDATA_H
#define CHEMICALDATA_H

#include <string>
#include <map>
#include <assert.h>
#include <memory>
#include <boost/concept_check.hpp>
#include <iostream>

using std::string;
struct MAtomType
{
    MAtomType() : mLongName("Unknown") {};
    MAtomType(const string shortName, const string longName,
       int atomic_number, float atomic_radius, float atomic_weight,
       bool isUnknown=false
        ):
        mShortName(shortName),
        mLongName(longName),
        mAtomicNumber(atomic_number),
        mAtomicRadius(atomic_radius),
        mAtomicWeight(atomic_weight),
        mIsUnknown(isUnknown)
    {
    };

    static const MAtomType& from_element_string(const string element_string)
    {
        if (_map.count(element_string))
            return _map[element_string];
        return _map["?"];
        //return MAtomType(element_string,  "Unknown", 0, 0, 0,  true);
    };
    static std::map<std::string, MAtomType> _map;
    string mShortName;
    string mLongName;
    int mAtomicNumber;
    float mAtomicRadius;
    float mAtomicWeight;
    bool mIsUnknown;
};

/**
 * withPolarHydrogen implies that residue should have a a polar backbone hydrogen that
 * can be added the same way like for standard non-Proline residues.
 */
enum class ResidueType:int { unknown=0, withPolarHydrogen, noPolarHydrogen, water, hetero };

struct ChemicalPropertiesResidue;
struct ChemicalPropertiesResidue
{
    ChemicalPropertiesResidue() :
        mSingleLetter("X"),
        mThreeLetter("UNK"),
        mName("Unknown"),
        mRestype(ResidueType::unknown)
    {};
    ChemicalPropertiesResidue(const string iSingleLetter, const string iThreeLetter, const string iName, ResidueType iRestype):
        mSingleLetter(iSingleLetter),
        mThreeLetter(iThreeLetter),
        mName(iName),
        mRestype(iRestype)
    {

    };

    string      mSingleLetter;
    string      mThreeLetter;
    string      mName;
    ResidueType mRestype;
    static ChemicalPropertiesResidue* from_three_letter(const string inThreeLetter)
    {
        if (!_map.count(inThreeLetter))
          _map[inThreeLetter] = ChemicalPropertiesResidue("?", inThreeLetter, "Unknown", ResidueType::unknown);

        return & (_map[inThreeLetter]);
    };
    static std::map<std::string, ChemicalPropertiesResidue> _map;

private:
    friend std::ostream &operator<<  ( std::ostream &output, const ChemicalPropertiesResidue &self )
    {
            //output << c.mSerial << " " <<  c.mName<<" "<< c.mLoc.X<< ", "   << c.mLoc.Y<< ", "   << c.mLoc.Z     ;
            output << self.mName;
            return output;
    }
};


#endif // CHEMICALDATA_H
