/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "pssc_config.h"
#include "HydrogenBond.h"

namespace po = boost::program_options;
using std::cout;
using std::cerr;

using std::endl;
using boost::to_upper;

bool checkFileExistence(const string& filename)
{
    ifstream f(filename.c_str());
    return f.is_open();
}

PSSC_config::PSSC_config(int argc, char* argv[])
{
    po::options_description desc("PSSC " VERSION " options");
    desc.add_options()
            ("help,h",                                                       "Display help message")
            ("input,i",             po::value<string>(), "Input file")
            ("output,o",    po::value<string>(), "Output file, use 'stdout' to output to screen")
            ("format,f",    po::value<string>()->default_value("DSSP"), "Output format: standard format, tab separated or JSON")
            ("energyfunc,u",        po::value<string>()->default_value("DSSP"), "Energy function to use")
            ("hydrogenbuild,b",     po::value<string>()->default_value("PDB"), "How to place hydrogen atoms")
            ("verbose,v",                                            "Verbose output")
            ("version",                                                      "Print version")
            ("debug,d",             po::value<int>(),        "Debug level (for even more verbose output)")
            ("hbondenergy,e",               po::value<double>()->default_value(-0.5), "Maximum H-Bond energy)")
            ;

    po::positional_options_description p;
    p.add("input", 1);
    p.add("output", 2);

    po::variables_map vm;
    po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    po::notify(vm);

    verbose = vm.count("verbose") != 0;
    if (vm.count("version"))
    {
        std::cout << "PSSC version " VERSION << std::endl;
        if (verbose)
        {
            cout << "forked from DSSP version 2.2.1" << endl;
            cout << "Boost version: " << (BOOST_VERSION / 100000)  << "." << ((BOOST_VERSION / 100) % 1000) << "." << (BOOST_VERSION % 100) << endl;
        }
        _exit = true;
    }

    if (vm.count("help") or not vm.count("input"))
    {
        cerr << desc << endl
             << endl
             << "Examples: " << endl
             << endl
             << "To calculate the secondary structure for the file 1crn.pdb and" << endl
             << "write the result to a file called 1crn.dssp, you type:" << endl
             << endl
             << "  " << argv[0] << " -i 1crn.pdb -o 1crn.dssp" << endl
             << endl;
#if defined(_MSC_VER)
            cerr << endl
                << "PSSC is a command line application, use the 'Command prompt' application" << endl
                << "to start " << argv[0] << " You can find the 'Command prompt' in the Start menu:" << endl
                << endl
                << "Start => Accessories => Command prompt" << endl
                << endl
                << endl
                << "Press any key to continue..." << endl;
            char ch = _getch();
#endif
        _exit = true;
        return ;
    }

    if (vm.count("debug"))
        debug = vm["debug"].as<int>();

    max_HBond_energy = vm["hbondenergy"].as<double>();

    string s_format = vm["format"].as<string>();
    to_upper(s_format);
    if (s_format == "DSSP" or s_format == "D")
    {
            output_format = pssc_output_format::DSSP;
    }
    else if (s_format == "TAB" or s_format == "T")
    {
           output_format = pssc_output_format::TAB;
    }
    else if (s_format == "JSON" or s_format == "J")
    {
        output_format = pssc_output_format::JSON;
    }
    else if (s_format == "COL" or s_format == "C")
    {
        output_format = pssc_output_format::COL;
    }
    else
    {
        string s = (NamedFormat("Invalid value provided for format: '%s'.\nAllowed values are 'DSSP', 'TAB' or 'JSON'. (Case insensitive.)\n") % s_format).str();
        handle_error(s);
        return ;
    }

    string o_energyfunc = vm["energyfunc"].as<string>();
    to_upper(o_energyfunc);
    if (o_energyfunc == "TEST" || o_energyfunc == "T")
    {
        hbond_efunc_descr = "test";
        HBond::_calculate_hbond_energy_callback = HBond::calculate_energy_test;
    }
    else if (o_energyfunc == "ESTAT" || o_energyfunc == "E" )
    {
        hbond_efunc_descr = "electrostatic";
        HBond::_calculate_hbond_energy_callback = HBond::calculate_energy_estat;
    }
    else if (o_energyfunc == "DSSP" || o_energyfunc == "D")
    {
        hbond_efunc_descr = "DSSP";
        HBond::_calculate_hbond_energy_callback = HBond::calculate_energy_dssp;
    }
    else
    {
        string s = (NamedFormat("Invalid value provided for energyfunction: '%s'.\nAllowed values are 'DSSP', 'ESTAT' or 'TEST'. (Case insensitive.)\n") % o_energyfunc).str();
        handle_error(s);
        return ;
    }
/*
    string o_hydrogenbuild = vm["hydrogenbuild"].as<string>();
    if (o_hydrogenbuild == "PDB" or o_hydrogenbuild == "pdb" or o_hydrogenbuild == "P" or o_hydrogenbuild == "p")
    {
            if (VERBOSE)
                    cerr << "Will use hydrogen atoms from PDB. Will add only missing." << endl;
            MResidue::SetUseHydrogenAtomsFromPDB(true);
    }
    else if (o_hydrogenbuild == "DSSP" or o_hydrogenbuild == "dssp" or o_hydrogenbuild == "D" or o_hydrogenbuild == "d")
    {
            if (VERBOSE)
                    cerr << "Will assign hydrogen placements like original DSSP. Will overwrite existing PDB hydrogen atoms." << endl;
            MResidue::SetUseHydrogenAtomsFromPDB(false);
    }
    else
    {
            throw po::validation_error(po::validation_error::invalid_option_value, "hydrogenbuild");
    }
*/

    input = vm["input"].as<string>();

    if (!checkFileExistence(input))
    {
        string s = (NamedFormat("Could not open file '%s'\n") % input).str();
        handle_error(s);
        return ;
    }

    return ;
}