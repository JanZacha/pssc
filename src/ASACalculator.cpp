/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "ASACalculator.h"

ASACalculator::ASACalculator(Protein& protein, double probe_radius, int N) :
protein(protein),
probe_radius(probe_radius),  n_sphere_points(-1)
{
    /*
    """
    Calculate Solvent Accessible Area(ASA) of atoms.

    */

    max_search_radius = 2 * (k_radius_for_asa_water + k_radius_for_asa_max);
    generate_sphere_points(N);
    fill_hashmap();
}

void ASACalculator::generate_sphere_points(int N)
/**
 * taken from DSSP for easier comparison. TODO: needs offset.
 */
{
    #define kPI 3.14159265359

    int P = 2 * N + 1;
    n_sphere_points = P;

    const double kGoldenRatio = (1 + sqrt(5.0)) / 2;

    asa_per_point = (4 * kPI) / P;

    for (int i = -N; i <= N; ++i)
    {
        double lat = asin((2.0 * i) / P);
        double lon = fmod(i, kGoldenRatio) * 2 * kPI / kGoldenRatio;

        vector3d p = {
            sin(lon) * cos(lat),
            cos(lon) * cos(lat),
            sin(lat)
        };

        sphere_points.push_back(p);
    }
}

vector3i ASACalculator::grid_vec(const vector3d &v)
{
    double fact = max_search_radius;
    return vector3i(v.X/fact, v.Y/fact, v.Z/fact);
}



std::vector<vector3i> connected_fields = {
    {-1, -1, 0}, {0, -1, 0}, {1,-1, 0},
    {-1,  0, 0}, {0,  0, 0}, {1, 0, 0},
    {-1,  1, 0}, {0,  1, 0}, {1, 1, 0},

    {-1, -1, 1}, {0, -1, 1}, {1,-1, 1},
    {-1,  0, 1}, {0,  0, 1}, {1, 0, 1},
    {-1,  1, 1}, {0,  1, 1}, {1, 1, 1},

    {-1, -1,-1}, {0, -1,-1}, {1,-1,-1},
    {-1,  0,-1}, {0,  0,-1}, {1, 0,-1},
    {-1,  1,-1}, {0,  1,-1}, {1, 1,-1}
  };

/**
 * see "Optimized Spatial Hashing for Collision Detection of Deformable Objects"
 * Matthias Teschner Bruno Heidelberger Matthias MÂ¨uller Danat Pomeranets Markus Gross
Computer Graphics Laboratory
ETH Zurich
http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf
 */
void ASACalculator::fill_hashmap()
{
    //cerr << "ASACalculator::fill_hashmap"<<endl;

    VecResPair ret;

    hashmap.reserve(5000);
    int n_atoms = 0;

    for (auto res: protein._residues)
    {
        for (auto& kv : res->_atoms_map)
        {
            if (kv.second.atomclass == AtomClass::hydrogen)
                continue;
            ++n_atoms;
            vector3i pos = grid_vec(kv.second.mLoc);
            assert ( &((*res)[kv.first]) == &(kv.second) );
            hashmap[ pos ].push_back(&(kv.second));
        }
    }

}


void ASACalculator::calculate()
{
   /* std::cerr <<  "ASACalculator::calculate()" << endl;
    std::cerr <<  "probe_radius " <<  probe_radius << endl;
    std::cerr <<  "n_sphere_points " <<  n_sphere_points << endl;*/
    double factor = 4.0 * kPI / n_sphere_points;
    double k_radius_for_asa_waterSQ = k_radius_for_asa_water * k_radius_for_asa_water;
    
    for (auto res: protein._residues)
    {
        for (auto& kv : res->_atoms_map)
        {
            Atom& atom_i = kv.second;

            if (atom_i.atomclass == AtomClass::hydrogen)
                continue;

            vector3i atom_i_gridpos = grid_vec(atom_i.mLoc);
            int atom_i_asa_dots_collided_n = 0;
            double search_radius = atom_i.radius_for_asa + k_radius_for_asa_max + 2 * k_radius_for_asa_water   ;
            double search_radiusSQ = search_radius * search_radius;
            double radius_i_full = k_radius_for_asa_water + atom_i.radius_for_asa;


            std::vector<Atom*> neighbors = {};

            for (const auto& con : connected_fields)
            {
                vector3i atom_j_gridpos = atom_i_gridpos + con;
                for (Atom* atom_j_ptr :  hashmap[atom_j_gridpos])
                {
                    if (atom_j_ptr == &atom_i)
                    {
                        continue;                           //cerr <<  "ok " << *atom_j_ptr <<  endl;
                    }

                    double distSQ = atom_i.mLoc.getDistanceFromSQ(atom_j_ptr->mLoc);
                    if (distSQ < search_radiusSQ)
                        neighbors.push_back(atom_j_ptr);
                }
            }                                               //  neighbors now filled with atoms
           // cerr << neighbors.size() << endl;
            const uint64 n_neighbors = neighbors.size();

            uint64 last_neighbor_j_with_clash = 0;
            for (vector3d asa_dot : sphere_points)
            {
                asa_dot = atom_i.mLoc + radius_i_full*asa_dot;
                bool point_collided = false;

                //for (auto atom_j_ptr : neighbors)
                for (uint64 _j = 0; _j < n_neighbors; ++_j)
                {
                    const uint64 j = (_j + last_neighbor_j_with_clash) % n_neighbors;
                    Atom* atom_j_ptr = neighbors[j];
                    const vector3d& atom_pos = atom_j_ptr->mLoc;
                    // double dist_to_pointSQ = asa_dot.getDistanceFromSQ(atom_j_ptr->mLoc);
                    const double dx = (asa_dot.X - atom_pos.X);
                    const double dy = (asa_dot.Y - atom_pos.Y);
                    const double dz = (asa_dot.Z - atom_pos.Z);
                    const double dist_to_pointSQ = dx*dx + dy*dy + dz*dz;
                    const double targetRad = k_radius_for_asa_water + atom_j_ptr->radius_for_asa;
                    const double targetRadSQ = targetRad*targetRad;
                    if (dist_to_pointSQ < targetRadSQ)
                    {
                        atom_i_asa_dots_collided_n++;
                        point_collided = true;
                        last_neighbor_j_with_clash = j;
                    }
                    if (point_collided)
                        break;
                }
            }
            int asa_dots_survived_n = n_sphere_points - atom_i_asa_dots_collided_n;
            assert (asa_dots_survived_n >= 0);
            atom_i.asa = factor * asa_dots_survived_n * (radius_i_full*radius_i_full);
        }
    }

    double total_asa = 0;
    for (auto res: protein._residues)
    {
        double res_asa = 0;
        for (auto& kv : res->_atoms_map)
        {
            Atom& atom_i = kv.second;
            if (atom_i.asa > 0)
            res_asa += atom_i.asa;
        }
        res->asa = res_asa;
        total_asa += res_asa;
    }
    protein.asa = total_asa;

}

void ASACalculator::dump()
{
    for (auto res: protein._residues)
    {
        cerr << *res << "\t" << res->asa <<  endl;
    }
    cerr <<  "total_asa " << protein.asa <<  endl;
    cerr << (4.0 * kPI / n_sphere_points) <<  "A^2 per point" << endl;
}
