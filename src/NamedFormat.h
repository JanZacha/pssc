#ifndef __NamedFormat__
#define __NamedFormat__

#include <string>
#include <vector>
#include <iostream>

#include <boost/format.hpp>
#include <boost/variant.hpp>

using boost::format;
using std::string;
using std::ostream;
using std::cerr;
using std::endl;

/**
 *
 *  NamedFormat - a thin wrapper around boost::format that allowes for usage of
 *  named Parameter.
 *
 *  Syntax: wherever the boost format string reads like %1$ or %1$.5f just replace
 *  the index with an arbitray, unique and case-sensitive key:
 *  %MYKEY$ or %MYKEY$.5f
 *
 *  This format may then be applied like this:
 *  std::cerr << NamedFormat("%MYKEY$ or %MYKEY$.5f") ("MYKEY", 6.66);
 *  std::cerr << NamedFormat("%first$ and %second$i") ("first", 6.66) ("second", 23);
 *
 *  So a key-value pair is used by means of the function call operator() instead of the modulo operator %.
 *  Multiple pairs can be chained and combination with positional arguments are possible.
 *  It might be wise to disallow positional arguments after the use of keyword arguments
 *    [something like  "..." ("key", "val") % (5)  ].
 *  So far this is not checked (and thus allowed) but this might change in the future.
 *
 *  This wrapper is thin because the keywords are just replaced with their corresponding
 *  integer indices. The resulting format string is then prossed with boost::format.
 *  When boost::format's constructor throws an error, this exception is catched and a
 *  named_format_error is thrown instead. This exception contains the format string after
 *  replacement of the keys for easier debugging.
 *
 *  Some examples are given in main.cpp.
 *
 * Note: A key may occur zero-, one- or multiple times in the format string. If it does not occur
 * there but is given to NamedFormat later, it is silently ignored.
 * TODO: The user should be allowed to configure NamedFormat to throw an exception if this happens.
 *
 * May 2014, Berlin
 * Jan Zacharias
 * AG Knapp

    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
 */



typedef boost::variant<int, double, string> vartype;

namespace boost {
    namespace io {
        class named_format_error : public std::exception
        {
        private:
            string _message;
        public:
            named_format_error(const string& message) : _message(message) {}
            virtual const char *what() const throw() {
                return _message.c_str();
            }
        };
    }
}

size_t ReplaceStringInPlace(string& subject, const string& search, const string& replace, char escape_char);

struct NamedFormat
{
    NamedFormat(string format_string)
    {
        _s = format_string;
    }

    void setDefaultForNonFinite(double default_val)
    {
        default_for_nonfinite = default_val;
        has_default_for_nonfinite = true;
    }

    NamedFormat& operator%(const vartype value)
    {
        return operator()(value);
    }

    NamedFormat& operator()(const vartype value)
    {
        _values.push_back(value);
        return *this;
    }

    NamedFormat& operator()(const string key, const vartype value)
    {
        ReplaceStringInPlace(_s, "%" + key + "$", boost::str(format("%%%i$")  % (_values.size()+1)), '%');
        ReplaceStringInPlace(_s, "%" + key + "%", boost::str(format("%%%i%%") % (_values.size()+1)), '%');
        _values.push_back(value);

        return *this;
    }

    string str() const
    {
        return to_format().str();
    }

    format to_format() const
    {
        format f;
        try
        {
            f = format(_s);
        }
        catch (boost::io::bad_format_string e)
        {
            format err_msg = format("%s: '%s'") % e.what() % _s;
            throw(boost::io::named_format_error(err_msg.str()));
        }
        for (const vartype it : _values)
        {
            if (has_default_for_nonfinite && it.type() == typeid(double) && !std::isfinite(boost::get<double>(it)))
                f % default_for_nonfinite;
            else
                f % it;
        }
        return f;
    }

private:
    string _s;
    std::vector<vartype> _values;

    bool has_default_for_nonfinite = false;
    double default_for_nonfinite;
    friend ostream &operator<<(ostream &output, const NamedFormat &self)
    {
        return output << self.to_format();
    }
};

#endif //__NamedFormat__